import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import dbConnect from "@/lib/mongodb";
import User from "@/models/User";
import Bike from "@/models/Bike";
import Ride from "@/models/Ride";
import Payment from "@/models/Payment";
import ProductPayment from "@/models/ProductPayment";
// jsPDF will be imported dynamically

export const dynamic = "force-dynamic";

function forbid() {
  return NextResponse.json({ message: "Forbidden" }, { status: 403 });
}

/**
 * GET /api/report?type=users|rides|sales&format=csv|pdf
 * Generate and download CSV or PDF reports
 */
export async function GET(req) {
  const session = await getServerSession(authOptions);
  if (!session?.user || session.user.role !== "admin") return forbid();

  try {
    const { searchParams } = new URL(req.url);
    const type = searchParams.get("type");
    const format = searchParams.get("format") || "csv"; // Default to CSV for backward compatibility

    if (!type || !["users", "rides", "sales"].includes(type)) {
      return NextResponse.json(
        { message: "Invalid report type" },
        { status: 400 }
      );
    }

    if (!["csv", "pdf"].includes(format)) {
      return NextResponse.json(
        { message: "Invalid format. Use 'csv' or 'pdf'" },
        { status: 400 }
      );
    }

    await dbConnect();

    const currentDate = new Date().toISOString().split('T')[0];
    let filename = `${type}-report-${currentDate}`;

    if (format === "pdf") {
      try {
        // Generate PDF report using dynamic import
        console.log("Starting PDF generation for type:", type);
        
        // Try different import methods
        let jsPDF;
        try {
          const jsPDFModule = await import("jspdf");
          jsPDF = jsPDFModule.default || jsPDFModule;
          console.log("jsPDF imported successfully");
        } catch (importError) {
          console.error("jsPDF import failed:", importError);
          throw new Error("Failed to import jsPDF library");
        }
        
        try {
          await import("jspdf-autotable");
          console.log("jspdf-autotable imported successfully");
        } catch (autoTableError) {
          console.error("jspdf-autotable import failed:", autoTableError);
          // Continue without autotable if it fails
        }
        
        const pdf = new jsPDF();
        console.log("jsPDF instance created successfully");
      
      // Add professional header
      pdf.setFontSize(24);
      pdf.setTextColor(41, 128, 185);
      pdf.setFont(undefined, 'bold');
      pdf.text(`${type.charAt(0).toUpperCase() + type.slice(1)} Report`, 20, 25);
      
      // Add header line
      pdf.setDrawColor(41, 128, 185);
      pdf.setLineWidth(2);
      pdf.line(20, 30, pdf.internal.pageSize.width - 20, 30);
      
      // Add report details
      pdf.setFontSize(10);
      pdf.setTextColor(100, 100, 100);
      pdf.setFont(undefined, 'normal');
      pdf.text(`Generated on: ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}`, 20, 40);
      pdf.text(`Generated by: ${session.user.username || session.user.email}`, 20, 45);
      pdf.text(`Report Type: ${type.toUpperCase()}`, 20, 50);

      let tableData = [];
      let columns = [];

      switch (type) {
        case "users":
          const users = await User.find({}, {
            username: 1,
            email: 1,
            role: 1,
            createdAt: 1,
            nic: 1
          }).lean();

          columns = ["Username", "Email", "Role", "NIC", "Registration Date"];
          tableData = users.map(user => [
            user.username || "N/A",
            user.email || "N/A",
            user.role || "N/A",
            user.nic || "N/A",
            new Date(user.createdAt).toLocaleDateString('en-US', { 
              year: 'numeric', 
              month: 'short', 
              day: 'numeric' 
            })
          ]);
          break;

        case "rides":
          const rides = await Ride.find({}, {
            userId: 1,
            bikeId: 1,
            startTime: 1,
            endTime: 1,
            distance: 1,
            duration: 1,
            status: 1
          }).lean();

          columns = ["User ID", "Bike ID", "Start Time", "End Time", "Distance (km)", "Duration (min)", "Status"];
          tableData = rides.map(ride => {
            const duration = ride.duration ? Math.round(ride.duration / 60000) : 0;
            // Format dates to be shorter and more readable
            const formatDateTime = (date) => {
              if (!date) return 'N/A';
              const d = new Date(date);
              return `${d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} ${d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}`;
            };
            
            return [
              ride.userId || 'N/A',
              ride.bikeId || 'N/A',
              formatDateTime(ride.startTime),
              formatDateTime(ride.endTime),
              ride.distance || 'N/A',
              duration || 'N/A',
              ride.status || 'N/A'
            ];
          });
          break;

        case "sales":
          const [productPayments, regularPayments] = await Promise.all([
            ProductPayment.find({}, {
              userId: 1,
              productId: 1,
              amount: 1,
              status: 1,
              createdAt: 1,
              paymentMethod: 1
            }).lean(),
            Payment.find({}, {
              userId: 1,
              amount: 1,
              status: 1,
              createdAt: 1,
              paymentMethod: 1,
              type: 1
            }).lean()
          ]);

          columns = ["Type", "User ID", "Product/Service ID", "Amount", "Status", "Payment Method", "Date"];
          
          // Format date function for sales
          const formatDate = (date) => {
            if (!date) return 'N/A';
            const d = new Date(date);
            return `${d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} ${d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}`;
          };

          // Product payments
          const productData = productPayments.map(payment => [
            "Product",
            payment.userId || 'N/A',
            payment.productId || 'N/A',
            payment.amount || 'N/A',
            payment.status || 'N/A',
            payment.paymentMethod || 'N/A',
            formatDate(payment.createdAt)
          ]);

          // Regular payments
          const regularData = regularPayments.map(payment => [
            payment.type || 'Service',
            payment.userId || 'N/A',
            "N/A",
            payment.amount || 'N/A',
            payment.status || 'N/A',
            payment.paymentMethod || 'N/A',
            formatDate(payment.createdAt)
          ]);

          tableData = [...productData, ...regularData];
          break;
      }

      // Add table to PDF with improved formatting
      try {
        pdf.autoTable({
          head: [columns],
          body: tableData,
          startY: 60,
          margin: { left: 15, right: 15 },
          styles: {
            fontSize: 8,
            cellPadding: 3,
            lineColor: [200, 200, 200],
            lineWidth: 0.5,
            textColor: [50, 50, 50],
            overflow: 'linebreak',
            halign: 'left',
            valign: 'middle',
            lineHeight: 1.2
          },
          headStyles: {
            fillColor: [41, 128, 185],
            textColor: 255,
            fontStyle: 'bold',
            fontSize: 10,
            halign: 'center',
            valign: 'middle'
          },
          alternateRowStyles: {
            fillColor: [248, 249, 250]
          },
          columnStyles: (() => {
            // Dynamic column styles based on report type
            if (type === "users") {
              return {
                0: { cellWidth: 30, halign: 'left' },   // Username
                1: { cellWidth: 50, halign: 'left' },   // Email (wider for full emails)
                2: { cellWidth: 20, halign: 'center' }, // Role
                3: { cellWidth: 30, halign: 'center' }, // NIC (wider for full numbers)
                4: { cellWidth: 35, halign: 'center' }  // Registration Date
              };
            } else if (type === "rides") {
              return {
                0: { cellWidth: 25, halign: 'left' },   // User ID
                1: { cellWidth: 25, halign: 'left' },   // Bike ID  
                2: { cellWidth: 35, halign: 'center' }, // Start Time
                3: { cellWidth: 35, halign: 'center' }, // End Time
                4: { cellWidth: 20, halign: 'center' }, // Distance
                5: { cellWidth: 20, halign: 'center' }, // Duration
                6: { cellWidth: 20, halign: 'center' }  // Status
              };
            } else if (type === "sales") {
              return {
                0: { cellWidth: 20, halign: 'center' }, // Type
                1: { cellWidth: 25, halign: 'left' },   // User ID
                2: { cellWidth: 30, halign: 'left' },   // Product/Service ID
                3: { cellWidth: 20, halign: 'center' }, // Amount
                4: { cellWidth: 20, halign: 'center' }, // Status
                5: { cellWidth: 25, halign: 'center' }, // Payment Method
                6: { cellWidth: 30, halign: 'center' }  // Date
              };
            }
            return {}; // Default empty styles
          })(),
          didDrawPage: (data) => {
            // Add page numbers
            const pageCount = pdf.internal.getNumberOfPages();
            const currentPage = pdf.internal.getCurrentPageInfo().pageNumber;
            pdf.setFontSize(8);
            pdf.setTextColor(128, 128, 128);
            pdf.text(`Page ${currentPage} of ${pageCount}`, pdf.internal.pageSize.width - 30, pdf.internal.pageSize.height - 10);
          }
        });
        console.log("PDF table generated successfully with improved formatting");
      } catch (autoTableError) {
        console.error("autoTable failed, creating enhanced simple table:", autoTableError);
        
        // Enhanced fallback: create a better formatted text-based table
        let y = 65;
        const pageWidth = pdf.internal.pageSize.width;
        const margin = 20;
        const tableWidth = pageWidth - (margin * 2);
        
        // Calculate column widths based on content with better spacing
        const colWidths = columns.map((col, index) => {
          const maxContentLength = Math.max(
            col.length,
            ...tableData.slice(0, 10).map(row => String(row[index] || '').length)
          );
          
          // Set minimum widths based on report type and column
          let minWidth = 20;
          if (type === "users") {
            if (index === 1) minWidth = 50; // Email column needs more space
            else if (index === 3) minWidth = 30; // NIC column needs more space
            else if (index === 4) minWidth = 35; // Date column needs more space
          } else if (type === "rides") {
            if (index === 2 || index === 3) minWidth = 35; // Time columns need more space
          } else if (type === "sales") {
            if (index === 2) minWidth = 30; // Product/Service ID needs more space
            else if (index === 6) minWidth = 30; // Date column needs more space
          }
          
          const calculatedWidth = Math.max(maxContentLength * 2.5, minWidth);
          return Math.min(calculatedWidth, tableWidth / columns.length);
        });
        
        // Ensure total width doesn't exceed page width
        const totalWidth = colWidths.reduce((sum, width) => sum + width, 0);
        if (totalWidth > tableWidth) {
          const scaleFactor = tableWidth / totalWidth;
          colWidths.forEach((width, index) => {
            colWidths[index] = width * scaleFactor;
          });
        }
        
        // Draw table border
        pdf.setDrawColor(200, 200, 200);
        pdf.setLineWidth(0.5);
        pdf.rect(margin, y - 5, tableWidth, 12);
        
        // Add headers with background
        pdf.setFillColor(41, 128, 185);
        pdf.rect(margin, y - 5, tableWidth, 12, 'F');
        
        pdf.setFontSize(10);
        pdf.setTextColor(255, 255, 255);
        pdf.setFont(undefined, 'bold');
        
        let x = margin + 5;
        columns.forEach((col, index) => {
          pdf.text(col, x, y + 3);
          x += colWidths[index];
        });
        
        y += 15;
        pdf.setFont(undefined, 'normal');
        pdf.setTextColor(50, 50, 50);
        
        // Add data rows with alternating colors
        tableData.slice(0, 25).forEach((row, rowIndex) => {
          if (y > pdf.internal.pageSize.height - 30) {
            pdf.addPage();
            y = 30;
          }
          
          // Alternate row background
          if (rowIndex % 2 === 0) {
            pdf.setFillColor(248, 249, 250);
            pdf.rect(margin, y - 3, tableWidth, 10, 'F');
          }
          
          // Draw row border
          pdf.setDrawColor(200, 200, 200);
          pdf.rect(margin, y - 3, tableWidth, 10);
          
          x = margin + 5;
          row.forEach((cell, index) => {
            let cellText = String(cell || 'N/A');
            
            // Smart truncation based on column type
            const maxChars = Math.floor(colWidths[index] / 2.5);
            if (cellText.length > maxChars) {
              if (type === "users" && index === 1) {
                // For email addresses, try to keep the domain visible
                const atIndex = cellText.indexOf('@');
                if (atIndex > 0 && atIndex < maxChars - 10) {
                  const domain = cellText.substring(atIndex);
                  const localPart = cellText.substring(0, atIndex);
                  const availableForLocal = maxChars - domain.length - 3;
                  if (availableForLocal > 0) {
                    cellText = localPart.substring(0, availableForLocal) + '...' + domain;
                  } else {
                    cellText = cellText.substring(0, maxChars - 3) + '...';
                  }
                } else {
                  cellText = cellText.substring(0, maxChars - 3) + '...';
                }
              } else {
                cellText = cellText.substring(0, maxChars - 3) + '...';
              }
            }
            pdf.text(cellText, x, y + 3);
            x += colWidths[index];
          });
          
          y += 12;
        });
        
        if (tableData.length > 25) {
          pdf.setFontSize(8);
          pdf.setTextColor(128, 128, 128);
          pdf.text(`... and ${tableData.length - 25} more records`, margin, y + 5);
        }
      }

      // Add professional summary at the bottom
      const finalY = pdf.lastAutoTable?.finalY || 200; // Fallback position
      
      // Add summary line
      pdf.setDrawColor(200, 200, 200);
      pdf.setLineWidth(0.5);
      pdf.line(20, finalY + 15, pdf.internal.pageSize.width - 20, finalY + 15);
      
      pdf.setFontSize(10);
      pdf.setTextColor(100, 100, 100);
      pdf.setFont(undefined, 'bold');
      pdf.text(`Report Summary`, 20, finalY + 25);
      
      pdf.setFont(undefined, 'normal');
      pdf.text(`Total Records: ${tableData.length}`, 20, finalY + 35);
      pdf.text(`Generated by: Cycle Chain Admin Dashboard`, 20, finalY + 45);
      pdf.text(`Report ID: ${type.toUpperCase()}-${Date.now().toString().slice(-6)}`, 20, finalY + 55);

        const pdfBuffer = pdf.output('arraybuffer');
        console.log("PDF buffer generated successfully, size:", pdfBuffer.byteLength);
        
        const headers = new Headers();
        headers.set('Content-Type', 'application/pdf');
        headers.set('Content-Disposition', `attachment; filename="${filename}.pdf"`);

        return new NextResponse(pdfBuffer, {
          status: 200,
          headers
        });
      } catch (pdfError) {
        console.error("PDF generation error:", pdfError);
        return NextResponse.json(
          { message: `PDF generation failed: ${pdfError.message}` },
          { status: 500 }
        );
      }

    } else {
      // Generate CSV report (existing logic)
      let csvData = "";

      switch (type) {
        case "users":
          const users = await User.find({}, {
            username: 1,
            email: 1,
            role: 1,
            createdAt: 1,
            nic: 1
          }).lean();

          csvData = "Username,Email,Role,NIC,Registration Date\n";
          users.forEach(user => {
            csvData += `"${user.username || ""}","${user.email}","${user.role}","${user.nic || ""}","${new Date(user.createdAt).toLocaleDateString()}"\n`;
          });
          break;

        case "rides":
          const rides = await Ride.find({}, {
            userId: 1,
            bikeId: 1,
            startTime: 1,
            endTime: 1,
            distance: 1,
            duration: 1,
            status: 1
          }).lean();

          csvData = "User ID,Bike ID,Start Time,End Time,Distance (km),Duration (min),Status\n";
          rides.forEach(ride => {
            const duration = ride.duration ? Math.round(ride.duration / 60000) : 0;
            csvData += `"${ride.userId}","${ride.bikeId}","${new Date(ride.startTime).toLocaleString()}","${ride.endTime ? new Date(ride.endTime).toLocaleString() : 'N/A'}","${ride.distance || 0}","${duration}","${ride.status}"\n`;
          });
          break;

        case "sales":
          const [productPayments, regularPayments] = await Promise.all([
            ProductPayment.find({}, {
              userId: 1,
              productId: 1,
              amount: 1,
              status: 1,
              createdAt: 1,
              paymentMethod: 1
            }).lean(),
            Payment.find({}, {
              userId: 1,
              amount: 1,
              status: 1,
              createdAt: 1,
              paymentMethod: 1,
              type: 1
            }).lean()
          ]);

          csvData = "Type,User ID,Product/Service ID,Amount,Status,Payment Method,Date\n";
          
          productPayments.forEach(payment => {
            csvData += `"Product","${payment.userId}","${payment.productId}","${payment.amount}","${payment.status}","${payment.paymentMethod || 'N/A'}","${new Date(payment.createdAt).toLocaleString()}"\n`;
          });

          regularPayments.forEach(payment => {
            csvData += `"${payment.type || 'Service'}","${payment.userId}","N/A","${payment.amount}","${payment.status}","${payment.paymentMethod || 'N/A'}","${new Date(payment.createdAt).toLocaleString()}"\n`;
          });
          break;
      }

      const headers = new Headers();
      headers.set('Content-Type', 'text/csv');
      headers.set('Content-Disposition', `attachment; filename="${filename}.csv"`);

      return new NextResponse(csvData, {
    status: 200,
        headers
      });
    }

  } catch (err) {
    console.error("Report generation error:", err);
    return NextResponse.json(
      { message: "Failed to generate report" },
      { status: 500 }
    );
  }
}